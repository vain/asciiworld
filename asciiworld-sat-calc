#!/usr/bin/env python


# Based on code and ideas of trehn's termtrack:
# https://github.com/trehn/termtrack


from math import acos, atan2, cos, degrees, radians, sin

import datetime
import ephem
import sys


def cartesian_rotation(lat, lon, r, steps):
    # Get latitude of one point on the small circle. We can easily do
    # this by adjusting the latitude but we have to avoid pushing over a
    # pole.
    if lat > 0:
        slat = degrees(lat) - degrees(r)
    else:
        slat = degrees(lat) + degrees(r)

    # Geographic coordinates to spherical coordinates.
    s_theta = -lat + radians(90)
    s_phi = lon

    # Cartesian coordinates of rotation axis.
    rx = sin(s_theta) * cos(s_phi)
    ry = sin(s_theta) * sin(s_phi)
    rz = cos(s_theta)

    # Rotation matrix around r{x,y,z} by alpha.
    alpha = radians(360.0 / steps)

    M = []
    M.append(rx**2 * (1 - cos(alpha)) + cos(alpha))
    M.append(ry * rx * (1 - cos(alpha)) + rz * sin(alpha))
    M.append(rz * rx * (1 - cos(alpha)) - ry * sin(alpha))

    M.append(rx * ry * (1 - cos(alpha)) - rz * sin(alpha))
    M.append(ry**2 * (1 - cos(alpha)) + cos(alpha))
    M.append(rz * ry * (1 - cos(alpha)) + rx * sin(alpha))

    M.append(rx * rz * (1 - cos(alpha)) + ry * sin(alpha))
    M.append(ry * rz * (1 - cos(alpha)) - rx * sin(alpha))
    M.append(rz**2 * (1 - cos(alpha)) + cos(alpha))

    # Cartesian coordinates of initial vector.
    s_theta = radians(-slat) + radians(90)
    s_phi = lon
    px = sin(s_theta) * cos(s_phi)
    py = sin(s_theta) * sin(s_phi)
    pz = cos(s_theta)

    for i in range(steps):
        # Rotate p{x,y,z}.
        p2x = px * M[0] + py * M[3] + pz * M[6]
        p2y = px * M[1] + py * M[4] + pz * M[7]
        p2z = px * M[2] + py * M[5] + pz * M[8]

        # For acos(), force p2z back into [-1, 1] which *might* happen
        # due to precision errors.
        p2z_fixed = max(-1, min(1, p2z))

        # Convert back to spherical coordinates and then geographic
        # coordinates.
        s_theta = acos(p2z_fixed)
        s_phi = atan2(p2y, p2x)

        lat = degrees(radians(90) - s_theta)
        lon = degrees(s_phi)

        print('{:f} {:f}'.format(lat, lon))

        # Use rotated p{x,y,z} as basis for next rotation.
        px = p2x
        py = p2y
        pz = p2z


lines = sys.stdin.read().strip().splitlines()

sat = ephem.readtle(*lines)

sat.compute(datetime.datetime.utcnow())
lon = sat.sublong
lat = sat.sublat
ele = sat.elevation
print('points')
print('{:f} {:f}'.format(degrees(lat), degrees(lon)))

print('track')
orbital_period = 60 * 60 * 24 / sat._n
orbit_offset = 0
while orbit_offset < orbital_period:
    orbit_offset += orbital_period / 150
    sat.compute(datetime.datetime.utcnow() +
            datetime.timedelta(seconds=orbit_offset))
    print('{:f} {:f}'.format(degrees(sat.sublat), degrees(sat.sublong)))

print('track')
orbit_offset = 0
while orbit_offset > -0.05 * orbital_period:
    orbit_offset -= orbital_period / 150
    sat.compute(datetime.datetime.utcnow() +
            datetime.timedelta(seconds=orbit_offset))
    print('{:f} {:f}'.format(degrees(sat.sublat), degrees(sat.sublong)))

if not (len(sys.argv) > 1 and sys.argv[1] == '-F'):
    # The satellite's footprint is a small circle centered at (lat, lon)
    # with radius r (spherical distance).
    print('track')
    r_earth = 6371000
    try:
        r = acos(r_earth / (r_earth + ele))
        cartesian_rotation(lat, lon, r, 128)
    except ValueError:
        print('Something is wrong with the elevation of the satellite: {}'.format(ele),
              file=sys.stderr
        )
